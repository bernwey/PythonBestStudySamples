#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2016/9/25 19:58
# @Author  : Hercwey
# @Site    : 
# @File    : deep_copy.py
# @Software: PyCharm Community Edition

"""
赋值、浅拷贝与深拷贝
"""

"""
赋值
"""
# 字符串是不可变的
a = "hello"
b = "hello"
c = a
print [id(x) for x in a, b, c]

# list 是可变的
a = ['hello']
b = ['hello']
c = a
print [id(x) for x in a, b, c]

"""
浅拷贝
"""
a = ['hello', [123, 234]]
b = a[:]
print [id(x) for x in a, b]
# [59713536, 59714576]
print [id(x) for x in a]  # 关注点1
# [59137632, 59713296]
print [id(x) for x in b]  # 关注点2
# [59137632, 59713296]
# 注：关注点1，2， a和b中的每个元素地址一样， 甚至第二个元素是list地址仍一致。
# 这就说明了浅拷贝的特点，只是将容器内的元素的地址复制了一份 。

"""
接着我们尝试修改a, b中的值：
"""
a[0] = 'world'
a[1].append(345)
print 'a = ', a, '\n\r', 'b = ', b
# a =  ['world', [123, 234, 345]]
# b =  ['hello', [123, 234, 345]]
# 注：a中第一个元素str改变，但是b中未改变；a中第二个元素改变，b中也改变。
# 这就符合不可变的对象修改会开辟新的空间，可变的对象修改不会开辟新空间。
# 也进一步证明了 浅拷贝仅仅是复制了容器中元素的地址 。

"""
深拷贝
"""
from copy import deepcopy

a = ['hello', [123, 234]]
b = deepcopy(a)
print [id(x) for x in a, b]
# [4496066824, 4496066680]
print [id(x) for x in a]
# [4496091584, 4496067040]
print [id(x) for x in b]
# [4496091584, 4496371792]
# 注： 深拷贝后，可以发现a, b地址以及a, b中list元素地址均不同。这才是完全 拷贝了一个副本 。

"""
修改a的值后：
"""
a[0] = 'world'
a[1].append(345)
print 'a = ', a, '\n\r', 'b = ', b
# a =  ['world', [123, 234, 345]]
# b =  ['hello', [123, 234]]
# 注：可以发现仅仅a修改了，b没有任何修改。 因为b是一个完全的副本，元素地址均与a不同，a修改，b不受影响 。

"""
总结：
1. 赋值是将一个对象的地址赋值给一个变量，让变量指向该地址（ 旧瓶装旧酒 ）。

2. 浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。
也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。

3. 深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。
也就是说（ 新瓶装新酒 ）。
"""
